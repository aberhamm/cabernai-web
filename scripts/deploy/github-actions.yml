# GitHub Actions workflow for deploying to DigitalOcean droplet
# Save this file as .github/workflows/deploy.yml

name: Deploy to DigitalOcean

on:
  push:
    branches:
      - main
      - production
  workflow_dispatch:

env:
  PROJECT_NAME: cabernai-web
  DEPLOY_USER: deploy

jobs:
  test:
    name: Test & Build
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Fix Sharp module for Linux CI
        run: |
          echo "ðŸ”§ Fixing Sharp module for Linux CI environment..."
          # Force reinstall Sharp with correct platform binary
          yarn workspace @repo/ui remove sharp
          yarn workspace @repo/ui add sharp
          echo "âœ… Sharp module reinstalled for Linux platform"

      - name: Lint code
        env:
          # Skip Sharp module during linting to avoid platform compatibility issues
          NEXT_SHARP: 0
        run: NODE_ENV=development turbo lint

      - name: Type check
        run: |
          cd apps/ui && NODE_ENV=development yarn typecheck
          cd ../strapi && NODE_ENV=development yarn generate:types

      - name: Build applications
        env:
          # Production environment variables for build - derived from domain
          NEXT_PUBLIC_APP_PUBLIC_URL: https://${{ vars.DOMAIN_NAME }}
          NEXT_PUBLIC_STRAPI_URL: https://${{ vars.DOMAIN_NAME }}
          NODE_ENV: production
        run: |
          echo "ðŸ” Debug: DOMAIN_NAME = '${{ vars.DOMAIN_NAME }}'"
          echo "ðŸ” Debug: NEXT_PUBLIC_APP_PUBLIC_URL = '$NEXT_PUBLIC_APP_PUBLIC_URL'"
          echo "ðŸ” Debug: NEXT_PUBLIC_STRAPI_URL = '$NEXT_PUBLIC_STRAPI_URL'"
          yarn build

  deploy:
    name: Deploy to Production
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://${{ vars.DOMAIN_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          echo "ðŸ” Setting up SSH connection to ${{ secrets.DROPLET_HOST }}..."

          # Try ssh-keyscan first (preferred method)
          echo "Attempting ssh-keyscan..."
          if timeout 30 ssh-keyscan -H ${{ secrets.DROPLET_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "âœ… Successfully added ${{ secrets.DROPLET_HOST }} to known hosts via ssh-keyscan"
          else
            echo "âš ï¸ ssh-keyscan failed, using StrictHostKeyChecking=no as fallback"
            echo "This is safe for automated deployments to known servers"

            # Create SSH config to disable host key checking for this specific host
            mkdir -p ~/.ssh
            cat >> ~/.ssh/config << EOF
          Host ${{ secrets.DROPLET_HOST }}
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null
              LogLevel ERROR
          EOF

            echo "âœ… SSH configured to skip host key verification for deployment"
          fi

      - name: Create deployment directory
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            sudo mkdir -p /opt/${{ env.PROJECT_NAME }}
            sudo chown ${{ env.DEPLOY_USER }}:${{ env.DEPLOY_USER }} /opt/${{ env.PROJECT_NAME }}
          "

      - name: Copy project files
        run: |
          rsync -avz --delete \
            --exclude node_modules \
            --exclude .git \
            --exclude .env \
            --exclude dist \
            --exclude .next \
            --exclude .cache \
            --exclude .tmp \
            ./ ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }}:/opt/${{ env.PROJECT_NAME }}/

      - name: Create environment file
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            cd /opt/${{ env.PROJECT_NAME }}

            # Create single .env file - automatically loaded into all containers via env_file directive
            cat > .env << 'EOF'
          # URLs - consolidated from domain name (public, not sensitive)
          NEXT_PUBLIC_APP_PUBLIC_URL=https://${{ vars.DOMAIN_NAME }}
          NEXT_PUBLIC_STRAPI_URL=https://${{ vars.DOMAIN_NAME }}
          NEXTAUTH_URL=https://${{ vars.DOMAIN_NAME }}
          APP_URL=https://${{ vars.DOMAIN_NAME }}

          # Database - DATABASE_URL is primary, individual params for compatibility
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          DATABASE_SCHEMA=${{ secrets.DATABASE_SCHEMA }}
          DATABASE_CLIENT=postgres
          DATABASE_HOST=${{ secrets.DATABASE_HOST }}
          DATABASE_PORT=${{ secrets.DATABASE_PORT }}
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_SSL=${{ secrets.DATABASE_SSL }}

          # Strapi secrets
          APP_KEYS=${{ secrets.APP_KEYS }}
          ADMIN_JWT_SECRET=${{ secrets.ADMIN_JWT_SECRET }}
          API_TOKEN_SALT=${{ secrets.API_TOKEN_SALT }}
          TRANSFER_TOKEN_SALT=${{ secrets.TRANSFER_TOKEN_SALT }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          PUBLIC_URL=https://${{ vars.DOMAIN_NAME }}
          HOST=0.0.0.0
          PORT=1337

          # NextAuth
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
          # NextAuth URL already set above

          # File upload - Cloudinary (name duplicated for Next.js compatibility)
          CLOUDINARY_NAME=${{ secrets.CLOUDINARY_NAME }}
          CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}
          NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_NAME }}

          # Optional services
          MAILGUN_API_KEY=${{ secrets.MAILGUN_API_KEY }}
          MAILGUN_DOMAIN=${{ secrets.MAILGUN_DOMAIN }}
          MAILGUN_EMAIL=${{ secrets.MAILGUN_EMAIL }}

          # Monitoring - Sentry (DSN duplicated for Next.js compatibility)
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          NEXT_PUBLIC_SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          SENTRY_SUPPRESS_GLOBAL_ERROR_HANDLER_FILE_WARNING=1

          # System
          CRON_ENABLED=true
          NODE_ENV=production
          NEXT_OUTPUT=standalone
          NEXT_IMAGES_UNOPTIMIZED=false

          # Additional Strapi Configuration
          CLIENT_URL=https://${{ vars.DOMAIN_NAME }}
          CLIENT_ACCOUNT_ACTIVATION_URL=https://${{ vars.DOMAIN_NAME }}/auth/activate
          EOF

            echo 'âœ… Created single .env file - automatically loaded into ALL containers!'
          "

      - name: Deploy application
        timeout-minutes: 25 # Optimized timeout
        run: |
          echo "ðŸš€ Starting optimized deployment..."
          echo "â±ï¸  Deployment timeout: 25 minutes (optimized)"
          echo "ðŸ“Š Deployment started at: $(date)"

          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            cd /opt/${{ env.PROJECT_NAME }}

            # Enable Docker BuildKit for faster builds
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1

            # Make scripts executable
            chmod +x scripts/deploy/deploy.sh

            # Run deployment
            ./scripts/deploy/deploy.sh production
          "

          echo "âœ… Deployment script completed at: $(date)"

      - name: Verify deployment
        run: |
          # Wait for services to start
          sleep 60

          # Check if services are responding
          if curl -f -s https://${{ vars.DOMAIN_NAME }}/health; then
            echo 'âœ… UI is responding'
          else
            echo 'âŒ UI is not responding'
            exit 1
          fi

          if curl -f -s https://${{ vars.DOMAIN_NAME }}/api/health; then
            echo 'âœ… API is responding'
          else
            echo 'âŒ API is not responding'
            exit 1
          fi

      - name: Notify deployment success
        if: success()
        run: echo "ðŸš€ Deployment successful!"

      - name: Debug deployment failure
        if: failure()
        timeout-minutes: 5 # Limit debug collection to 5 minutes
        run: |
          echo "âŒ Deployment failed!"
          echo "ðŸ“Š Collecting debug information..."
          echo "â±ï¸  Debug collection timeout: 5 minutes"
          echo "ðŸ“Š Debug collection started at: $(date)"

          # Collect system information with timeouts
          timeout 300 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            echo '=== SYSTEM STATUS ==='
            timeout 10 date || echo 'date command timed out'
            timeout 10 uptime || echo 'uptime command timed out'
            timeout 15 df -h || echo 'df command timed out'
            timeout 10 free -h || echo 'free command timed out'

            echo '=== DOCKER STATUS ==='
            timeout 10 docker --version || echo 'docker version check timed out'
            timeout 10 docker-compose --version || echo 'docker-compose version check timed out'
            timeout 30 docker system df || echo 'docker system df timed out'
            timeout 20 docker images | head -10 || echo 'docker images command timed out'

            echo '=== CONTAINER STATUS ==='
            cd /opt/${{ env.PROJECT_NAME }} || exit 1
            timeout 30 docker-compose ps || echo 'container status check timed out'

            echo '=== CONTAINER LOGS (last 50 lines each) ==='
            timeout 60 docker-compose logs --tail=50 ui || echo 'UI logs collection timed out'
            timeout 60 docker-compose logs --tail=50 strapi || echo 'Strapi logs collection timed out'

            echo '=== NGINX STATUS ==='
            timeout 15 systemctl status nginx || echo 'nginx status check timed out'
            timeout 10 nginx -t || echo 'nginx config test timed out'
            timeout 10 ls -la /etc/nginx/sites-enabled/ || echo 'nginx sites listing timed out'

            echo '=== NETWORK STATUS ==='
            timeout 15 netstat -tulpn | grep -E ':(80|443|3000|1337)' || echo 'network status check timed out'

            echo '=== RECENT SYSTEM LOGS ==='
            timeout 30 journalctl --since '10 minutes ago' --no-pager | tail -50 || echo 'system logs collection timed out'

            echo '=== DEBUG COLLECTION COMPLETED ==='
            date
          " || echo "âš ï¸ Debug information collection failed or timed out"

          echo "ðŸ“Š Debug collection completed at: $(date)"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "âŒ Deployment failed!"
          echo "ðŸ“‹ Common issues to check:"
          echo "1. Ensure server setup is complete"
          echo "2. Check that ports 3000 and 1337 are available"
          echo "3. Verify sufficient disk space and memory"
          echo "4. Check the debug information above for specific errors"
