# GitHub Actions workflow for deploying to DigitalOcean droplet (MULTI-SITE VERSION)
# Save this file as .github/workflows/deploy-multi-site.yml
#
# IMPORTANT: This is for MULTI-SITE deployment only!
# You MUST run setup-existing-droplet.sh on your server first!

name: Deploy to DigitalOcean (Multi-Site)

on:
  push:
    branches:
      - main
      - production
  workflow_dispatch:

env:
  PROJECT_NAME: cabernai-web
  DEPLOY_USER: deploy

jobs:
  test:
    name: Test & Build
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Lint code
        run: NODE_ENV=development yarn lint

      - name: Type check
        run: |
          cd apps/ui && NODE_ENV=development yarn typecheck
          cd ../strapi && NODE_ENV=development yarn generate:types

      - name: Build applications
        env:
          # Production environment variables for build - derived from domain
          NEXT_PUBLIC_APP_PUBLIC_URL: https://${{ vars.DOMAIN_NAME }}
          NEXT_PUBLIC_STRAPI_URL: https://${{ vars.DOMAIN_NAME }}
          NODE_ENV: production
        run: |
          echo "üîç Debug: DOMAIN_NAME = '${{ vars.DOMAIN_NAME }}'"
          echo "üîç Debug: NEXT_PUBLIC_APP_PUBLIC_URL = '$NEXT_PUBLIC_APP_PUBLIC_URL'"
          echo "üîç Debug: NEXT_PUBLIC_STRAPI_URL = '$NEXT_PUBLIC_STRAPI_URL'"
          yarn build

  deploy:
    name: Deploy to Production (Multi-Site)
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://${{ vars.DOMAIN_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          echo "üîç Setting up SSH connection to ${{ secrets.DROPLET_HOST }}..."

          # Try ssh-keyscan first (preferred method)
          echo "Attempting ssh-keyscan..."
          if timeout 30 ssh-keyscan -H ${{ secrets.DROPLET_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "‚úÖ Successfully added ${{ secrets.DROPLET_HOST }} to known hosts via ssh-keyscan"
          else
            echo "‚ö†Ô∏è ssh-keyscan failed, using StrictHostKeyChecking=no as fallback"
            echo "This is safe for automated deployments to known servers"

            # Create SSH config to disable host key checking for this specific host
            mkdir -p ~/.ssh
            cat >> ~/.ssh/config << EOF
          Host ${{ secrets.DROPLET_HOST }}
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null
              LogLevel ERROR
          EOF

            echo "‚úÖ SSH configured to skip host key verification for deployment"
          fi

      - name: Verify multi-site setup exists
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            # Check if multi-site setup was completed
            if [[ ! -f /opt/${{ env.PROJECT_NAME }}/docker-compose.multi-site.yml ]]; then
              echo '‚ùå Multi-site setup not found!'
              echo 'You must run setup-existing-droplet.sh on your server first.'
              echo 'See README-DEPLOYMENT.md multi-site section for instructions.'
              exit 1
            fi

            # Check if nginx is running (should exist for multi-site)
            if ! systemctl is-active --quiet nginx; then
              echo '‚ùå Nginx not running! Multi-site requires existing nginx.'
              exit 1
            fi

            echo '‚úÖ Multi-site environment verified'
          "

      - name: Create deployment directory
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            sudo mkdir -p /opt/${{ env.PROJECT_NAME }}
            sudo chown ${{ env.DEPLOY_USER }}:${{ env.DEPLOY_USER }} /opt/${{ env.PROJECT_NAME }}
          "

      - name: Copy project files
        run: |
          rsync -avz --delete \
            --exclude node_modules \
            --exclude .git \
            --exclude .env \
            --exclude dist \
            --exclude .next \
            --exclude .cache \
            --exclude .tmp \
            ./ ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }}:/opt/${{ env.PROJECT_NAME }}/

      - name: Create environment file
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            cd /opt/${{ env.PROJECT_NAME }}

            # Create single .env file - automatically loaded into all containers via env_file directive
            cat > .env << 'EOF'
          # URLs - consolidated from domain name (public, not sensitive)
          NEXT_PUBLIC_APP_PUBLIC_URL=https://${{ vars.DOMAIN_NAME }}
          NEXT_PUBLIC_STRAPI_URL=https://${{ vars.DOMAIN_NAME }}
          NEXTAUTH_URL=https://${{ vars.DOMAIN_NAME }}
          APP_URL=https://${{ vars.DOMAIN_NAME }}

          # Database - DATABASE_URL is primary, individual params for compatibility
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          DATABASE_SCHEMA=${{ secrets.DATABASE_SCHEMA }}
          DATABASE_CLIENT=postgres
          DATABASE_HOST=${{ secrets.DATABASE_HOST }}
          DATABASE_PORT=${{ secrets.DATABASE_PORT }}
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_SSL=${{ secrets.DATABASE_SSL }}

          # Strapi secrets
          APP_KEYS=${{ secrets.APP_KEYS }}
          ADMIN_JWT_SECRET=${{ secrets.ADMIN_JWT_SECRET }}
          API_TOKEN_SALT=${{ secrets.API_TOKEN_SALT }}
          TRANSFER_TOKEN_SALT=${{ secrets.TRANSFER_TOKEN_SALT }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          PUBLIC_URL=https://${{ vars.DOMAIN_NAME }}
          HOST=0.0.0.0
          PORT=1337

          # NextAuth
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
          # NextAuth URL already set above

          # File upload - Cloudinary (name duplicated for Next.js compatibility)
          CLOUDINARY_NAME=${{ secrets.CLOUDINARY_NAME }}
          CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}
          NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_NAME }}

          # Optional services
          MAILGUN_API_KEY=${{ secrets.MAILGUN_API_KEY }}
          MAILGUN_DOMAIN=${{ secrets.MAILGUN_DOMAIN }}
          MAILGUN_EMAIL=${{ secrets.MAILGUN_EMAIL }}

          # Monitoring - Sentry (DSN duplicated for Next.js compatibility)
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          NEXT_PUBLIC_SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          SENTRY_SUPPRESS_GLOBAL_ERROR_HANDLER_FILE_WARNING=1

          # System
          CRON_ENABLED=true
          NODE_ENV=production
          NEXT_OUTPUT=standalone
          NEXT_IMAGES_UNOPTIMIZED=false

          # Additional Strapi Configuration
          CLIENT_URL=https://${{ vars.DOMAIN_NAME }}
          CLIENT_ACCOUNT_ACTIVATION_URL=https://${{ vars.DOMAIN_NAME }}/auth/activate
          EOF

            echo '‚úÖ Created single .env file - automatically loaded into ALL containers!'
          "

      - name: Deploy application (Multi-Site)
        timeout-minutes: 30 # Optimized timeout
        run: |
          echo "üöÄ Starting optimized multi-site deployment..."
          echo "‚è±Ô∏è  Deployment timeout: 30 minutes (optimized)"
          echo "üìä Deployment started at: $(date)"

          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            cd /opt/${{ env.PROJECT_NAME }}

            # Enable Docker BuildKit for faster builds
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1

            # Make scripts executable
            chmod +x scripts/deploy/deploy-multi-site.sh

            # Run MULTI-SITE deployment
            ./scripts/deploy/deploy-multi-site.sh production
          "

          echo "‚úÖ Deployment script completed at: $(date)"

      - name: Verify deployment
        run: |
          # Wait for services to start
          sleep 60

          # Check if services are responding
          if curl -f -s https://${{ vars.DOMAIN_NAME }}/health; then
            echo '‚úÖ UI is responding'
          else
            echo '‚ùå UI is not responding'
            exit 1
          fi

          if curl -f -s https://${{ vars.DOMAIN_NAME }}/api/health; then
            echo '‚úÖ API is responding'
          else
            echo '‚ùå API is not responding'
            exit 1
          fi

          # Verify local ports are bound (multi-site specific)
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            if curl -f -s http://127.0.0.1:3000/ > /dev/null; then
              echo '‚úÖ UI running on localhost:3000'
            else
              echo '‚ùå UI not accessible on localhost:3000'
              exit 1
            fi

            if curl -f -s http://127.0.0.1:1337/ > /dev/null; then
              echo '‚úÖ Strapi running on localhost:1337'
            else
              echo '‚ùå Strapi not accessible on localhost:1337'
              exit 1
            fi
          "

      - name: Notify deployment success
        if: success()
        run: echo "üöÄ Multi-Site Deployment successful!"

      - name: Debug deployment failure
        if: failure()
        timeout-minutes: 5 # Limit debug collection to 5 minutes
        run: |
          echo "‚ùå Multi-Site Deployment failed!"
          echo "üìä Collecting debug information..."
          echo "‚è±Ô∏è  Debug collection timeout: 5 minutes"
          echo "üìä Debug collection started at: $(date)"

          # Collect system information with timeouts
          timeout 300 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            echo '=== SYSTEM STATUS ==='
            timeout 10 date || echo 'date command timed out'
            timeout 10 uptime || echo 'uptime command timed out'
            timeout 15 df -h || echo 'df command timed out'
            timeout 10 free -h || echo 'free command timed out'

            echo '=== DOCKER STATUS ==='
            timeout 10 docker --version || echo 'docker version check timed out'
            timeout 10 docker-compose --version || echo 'docker-compose version check timed out'
            timeout 30 docker system df || echo 'docker system df timed out'
            timeout 20 docker images | head -10 || echo 'docker images command timed out'

            echo '=== CONTAINER STATUS ==='
            cd /opt/${{ env.PROJECT_NAME }} || exit 1
            timeout 30 docker-compose -f docker-compose.multi-site.yml ps || echo 'container status check timed out'

            echo '=== CONTAINER LOGS (last 50 lines each) ==='
            timeout 60 docker-compose -f docker-compose.multi-site.yml logs --tail=50 ui || echo 'UI logs collection timed out'
            timeout 60 docker-compose -f docker-compose.multi-site.yml logs --tail=50 strapi || echo 'Strapi logs collection timed out'

            echo '=== NGINX STATUS ==='
            timeout 15 systemctl status nginx || echo 'nginx status check timed out'
            timeout 10 nginx -t || echo 'nginx config test timed out'
            timeout 10 ls -la /etc/nginx/sites-enabled/ || echo 'nginx sites listing timed out'

            echo '=== NETWORK STATUS ==='
            timeout 15 netstat -tulpn | grep -E ':(80|443|3000|1337)' || echo 'network status check timed out'

            echo '=== RECENT SYSTEM LOGS ==='
            timeout 30 journalctl --since '10 minutes ago' --no-pager | tail -50 || echo 'system logs collection timed out'

            echo '=== DEBUG COLLECTION COMPLETED ==='
            date
          " || echo "‚ö†Ô∏è Debug information collection failed or timed out"

          echo "üìä Debug collection completed at: $(date)"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå Multi-Site Deployment failed!"
          echo "üìã Common issues to check:"
          echo "1. Run setup-existing-droplet.sh first for multi-site setup"
          echo "2. Ensure nginx is properly configured for multi-site"
          echo "3. Check that ports 3000 and 1337 are available"
          echo "4. Verify sufficient disk space and memory"
          echo "5. Check the debug information above for specific errors"
