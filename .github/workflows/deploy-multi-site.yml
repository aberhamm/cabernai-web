# GitHub Actions workflow for deploying to DigitalOcean droplet (MULTI-SITE VERSION)
# Save this file as .github/workflows/deploy-multi-site.yml
#
# IMPORTANT: This is for MULTI-SITE deployment only!
# You MUST run setup-existing-droplet.sh on your server first!

name: Deploy to DigitalOcean (Multi-Site)

on:
  push:
    branches:
      - main
      - production
  workflow_dispatch:

env:
  PROJECT_NAME: cabernai-web
  DEPLOY_USER: deploy

jobs:
  test:
    name: Test & Build
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        env:
          # Force Sharp to download correct binary for CI platform
          SHARP_IGNORE_GLOBAL_LIBVIPS: 1
        run: |
          yarn install --frozen-lockfile
          echo "üîß Rebuilding Sharp for CI platform..."
          npm rebuild sharp || echo "Sharp rebuild failed, continuing..."

      - name: Lint code
        run: NODE_ENV=development yarn lint

      - name: Type check
        run: |
          cd apps/ui && NODE_ENV=development yarn typecheck
          cd ../strapi && NODE_ENV=development yarn generate:types

      - name: Build applications
        env:
          # Production environment variables for build - derived from domain
          NEXT_PUBLIC_APP_PUBLIC_URL: https://${{ vars.DOMAIN_NAME }}
          NEXT_PUBLIC_STRAPI_URL: https://${{ vars.DOMAIN_NAME }}
          NODE_ENV: production
        run: |
          echo "üîç Debug: DOMAIN_NAME = '${{ vars.DOMAIN_NAME }}'"
          echo "üîç Debug: NEXT_PUBLIC_APP_PUBLIC_URL = '$NEXT_PUBLIC_APP_PUBLIC_URL'"
          echo "üîç Debug: NEXT_PUBLIC_STRAPI_URL = '$NEXT_PUBLIC_STRAPI_URL'"
          yarn build

  deploy:
    name: Deploy to Production (Multi-Site)
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://${{ vars.DOMAIN_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          echo "üîç Setting up SSH connection to ${{ secrets.DROPLET_HOST }}..."

          # Try ssh-keyscan first (preferred method)
          echo "Attempting ssh-keyscan..."
          if timeout 30 ssh-keyscan -H ${{ secrets.DROPLET_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "‚úÖ Successfully added ${{ secrets.DROPLET_HOST }} to known hosts via ssh-keyscan"
          else
            echo "‚ö†Ô∏è ssh-keyscan failed, using StrictHostKeyChecking=no as fallback"
            echo "This is safe for automated deployments to known servers"

            # Create SSH config to disable host key checking for this specific host
            mkdir -p ~/.ssh
            cat >> ~/.ssh/config << EOF
          Host ${{ secrets.DROPLET_HOST }}
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null
              LogLevel ERROR
          EOF

            echo "‚úÖ SSH configured to skip host key verification for deployment"
          fi

      - name: Verify multi-site setup exists
        run: |
          echo "üîç Testing SSH connection and verifying multi-site setup..."

          # Test SSH connection first
          if ! timeout 30 ssh -o ConnectTimeout=10 -o BatchMode=yes ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "echo 'SSH connection successful'"; then
            echo "‚ùå SSH connection failed!"
            echo "üîç Troubleshooting steps:"
            echo "1. Check if DROPLET_HOST secret is correct: ${{ secrets.DROPLET_HOST }}"
            echo "2. Verify SSH_PRIVATE_KEY secret is the correct private key"
            echo "3. Ensure the deploy user exists and has the correct public key"
            echo "4. Check if the server is running and accessible"
            exit 1
          fi

          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            # Check if multi-site setup was completed
            if [[ ! -f /opt/${{ env.PROJECT_NAME }}/docker-compose.multi-site.yml ]]; then
              echo '‚ùå Multi-site setup not found!'
              echo 'You must run setup-existing-droplet.sh on your server first.'
              echo 'See README-DEPLOYMENT.md multi-site section for instructions.'
              exit 1
            fi

            # Check if nginx is running (should exist for multi-site)
            if ! systemctl is-active --quiet nginx; then
              echo '‚ùå Nginx not running! Multi-site requires existing nginx.'
              exit 1
            fi

            echo '‚úÖ Multi-site environment verified'
          "

      - name: Create deployment directory
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            sudo mkdir -p /opt/${{ env.PROJECT_NAME }}
            sudo chown ${{ env.DEPLOY_USER }}:${{ env.DEPLOY_USER }} /opt/${{ env.PROJECT_NAME }}
          "

      - name: Copy project files
        run: |
          rsync -avz --delete \
            --exclude node_modules \
            --exclude .git \
            --exclude .env \
            --exclude dist \
            --exclude .next \
            --exclude .cache \
            --exclude .tmp \
            ./ ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }}:/opt/${{ env.PROJECT_NAME }}/

      - name: Create environment file
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            cd /opt/${{ env.PROJECT_NAME }}

            # Create single .env file - automatically loaded into all containers via env_file directive
            cat > .env << 'EOF'
          # URLs - consolidated from domain name (public, not sensitive)
          NEXT_PUBLIC_APP_PUBLIC_URL=https://${{ vars.DOMAIN_NAME }}
          NEXT_PUBLIC_STRAPI_URL=https://${{ vars.DOMAIN_NAME }}
          NEXTAUTH_URL=https://${{ vars.DOMAIN_NAME }}
          APP_URL=https://${{ vars.DOMAIN_NAME }}

          # Database - DATABASE_URL is primary, individual params for compatibility
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          DATABASE_SCHEMA=${{ secrets.DATABASE_SCHEMA }}
          DATABASE_CLIENT=postgres
          DATABASE_HOST=${{ secrets.DATABASE_HOST }}
          DATABASE_PORT=${{ secrets.DATABASE_PORT }}
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_SSL=${{ secrets.DATABASE_SSL }}

          # Strapi secrets
          APP_KEYS=${{ secrets.APP_KEYS }}
          ADMIN_JWT_SECRET=${{ secrets.ADMIN_JWT_SECRET }}
          API_TOKEN_SALT=${{ secrets.API_TOKEN_SALT }}
          TRANSFER_TOKEN_SALT=${{ secrets.TRANSFER_TOKEN_SALT }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          PUBLIC_URL=https://${{ vars.DOMAIN_NAME }}
          HOST=0.0.0.0
          PORT=1337

          # NextAuth
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
          # NextAuth URL already set above

          # File upload - Cloudinary (name duplicated for Next.js compatibility)
          CLOUDINARY_NAME=${{ secrets.CLOUDINARY_NAME }}
          CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}
          NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_NAME }}

          # Optional services
          MAILGUN_API_KEY=${{ secrets.MAILGUN_API_KEY }}
          MAILGUN_DOMAIN=${{ secrets.MAILGUN_DOMAIN }}
          MAILGUN_EMAIL=${{ secrets.MAILGUN_EMAIL }}

          # Monitoring - Sentry (DSN duplicated for Next.js compatibility)
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          NEXT_PUBLIC_SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          SENTRY_SUPPRESS_GLOBAL_ERROR_HANDLER_FILE_WARNING=1

          # System
          CRON_ENABLED=true
          NODE_ENV=production
          NEXT_OUTPUT=standalone
          NEXT_IMAGES_UNOPTIMIZED=false

          # Additional Strapi Configuration
          CLIENT_URL=https://${{ vars.DOMAIN_NAME }}
          CLIENT_ACCOUNT_ACTIVATION_URL=https://${{ vars.DOMAIN_NAME }}/auth/activate
          EOF

            echo '‚úÖ Created single .env file - automatically loaded into ALL containers!'
          "

      - name: Deploy application (Multi-Site)
        timeout-minutes: 30  # Reduced timeout due to optimizations
        run: |
          echo "üöÄ Starting optimized multi-site deployment..."
          echo "‚è±Ô∏è  Deployment timeout: 30 minutes (reduced from 45 due to build optimizations)"
          echo "üìä Deployment started at: $(date)"

          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            cd /opt/${{ env.PROJECT_NAME }}

            # Show initial system status
            echo 'üìä System status before deployment:'
            df -h /opt
            free -h
            docker system df || true

            # Enable Docker BuildKit for faster builds
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1

            # Make scripts executable
            chmod +x scripts/deploy/deploy-multi-site.sh

            # Run MULTI-SITE deployment with verbose logging
            echo 'üöÄ Starting optimized deployment script...'
            ./scripts/deploy/deploy-multi-site.sh production
          "

          echo "‚úÖ Deployment script completed at: $(date)"

      - name: Verify deployment
        timeout-minutes: 10  # Set timeout for verification
        run: |
          echo "üîç Starting deployment verification..."
          echo "‚è±Ô∏è  Verification timeout: 10 minutes"
          echo "üìä Verification started at: $(date)"

                    # Progressive verification with better logging and safety checks
          echo "‚è≥ Waiting for services to fully initialize..."
          max_attempts=12
          attempt_timeout=15  # timeout per attempt
          total_timeout=300   # 5 minutes total
          start_time=$(date +%s)

          for i in $(seq 1 $max_attempts); do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))

            # Safety check: abort if total time exceeded
            if [[ $elapsed -gt $total_timeout ]]; then
              echo "üö® SAFETY: Total verification time exceeded ${total_timeout}s. Aborting."
              exit 1
            fi

            # Safety check: validate iteration number
            if [[ ! $i =~ ^[0-9]+$ ]] || [[ $i -lt 1 ]] || [[ $i -gt $max_attempts ]]; then
              echo "üö® SAFETY: Invalid iteration number: $i. Aborting."
              exit 1
            fi

            echo "üîç Verification attempt $i/$max_attempts (${elapsed}s elapsed, max ${total_timeout}s)..."

            # Use timeout for sleep to prevent hanging
            timeout $attempt_timeout sleep 10 || {
              echo "üö® SAFETY: Sleep command timed out. System may be unresponsive."
              exit 1
            }

            # Quick check if containers are running with timeout
            echo "üìä Checking container status..."
            if ! timeout 30 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
              echo 'üìä Container status:'
              cd /opt/${{ env.PROJECT_NAME }}
              timeout 20 docker-compose -f docker-compose.multi-site.yml ps
            "; then
              echo "‚ö†Ô∏è Container status check timed out or failed"
            fi

            # Test local endpoints first (faster) with timeout
            echo "üîç Testing local endpoints..."
            if timeout 30 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
              timeout 10 curl -f -s --max-time 5 http://127.0.0.1:3000/ > /dev/null &&
              timeout 10 curl -f -s --max-time 5 http://127.0.0.1:1337/ > /dev/null
            "; then
              echo "‚úÖ Local endpoints responding, testing public endpoints..."
              break
            elif [[ $i -eq $max_attempts ]]; then
              echo "‚ùå Local endpoints not responding after $max_attempts attempts (${elapsed}s total)"
              timeout 60 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
                cd /opt/${{ env.PROJECT_NAME }}
                echo 'üìã Container logs:'
                timeout 45 docker-compose -f docker-compose.multi-site.yml logs --tail=30 || echo 'Log collection timed out'
              " || echo "Debug info collection failed"
              exit 1
            else
              echo "‚è≥ Services still initializing... (attempt $i/$max_attempts)"
            fi
          done

          # Test public endpoints
          echo "üåê Testing public endpoints..."

          # Test UI through domain with safety checks
          ui_max_attempts=5
          ui_retry_delay=15
          ui_timeout=20

          for attempt in $(seq 1 $ui_max_attempts); do
            # Safety check: validate attempt number
            if [[ ! $attempt =~ ^[1-5]$ ]]; then
              echo "üö® SAFETY: Invalid UI attempt number: $attempt. Aborting."
              exit 1
            fi

            if timeout $ui_timeout curl -f -s --max-time 10 https://${{ vars.DOMAIN_NAME }}/ > /dev/null; then
              echo "‚úÖ UI is responding via https://${{ vars.DOMAIN_NAME }}/ (attempt $attempt)"
              break
            elif [[ $attempt -eq $ui_max_attempts ]]; then
              echo "‚ùå UI is not responding via public domain after $ui_max_attempts attempts"
              exit 1
            else
              echo "‚è≥ UI not ready via public domain, attempt $attempt/$ui_max_attempts..."
              timeout $((ui_retry_delay + 5)) sleep $ui_retry_delay || {
                echo "üö® SAFETY: UI retry sleep timed out. System may be unresponsive."
                exit 1
              }
            fi
          done

          # Test API through domain with safety checks
          api_max_attempts=5
          api_retry_delay=15
          api_timeout=20

          for attempt in $(seq 1 $api_max_attempts); do
            # Safety check: validate attempt number
            if [[ ! $attempt =~ ^[1-5]$ ]]; then
              echo "üö® SAFETY: Invalid API attempt number: $attempt. Aborting."
              exit 1
            fi

            if timeout $api_timeout curl -f -s --max-time 10 https://${{ vars.DOMAIN_NAME }}/api/ > /dev/null; then
              echo "‚úÖ API is responding via https://${{ vars.DOMAIN_NAME }}/api/ (attempt $attempt)"
              break
            elif [[ $attempt -eq $api_max_attempts ]]; then
              echo "‚ùå API is not responding via public domain after $api_max_attempts attempts"
              exit 1
            else
              echo "‚è≥ API not ready via public domain, attempt $attempt/$api_max_attempts..."
              timeout $((api_retry_delay + 5)) sleep $api_retry_delay || {
                echo "üö® SAFETY: API retry sleep timed out. System may be unresponsive."
                exit 1
              }
            fi
          done

          # Final verification of local ports
          echo "üîç Final verification of local ports..."
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            if curl -f -s --max-time 5 http://127.0.0.1:3000/ > /dev/null; then
              echo '‚úÖ UI running on localhost:3000'
            else
              echo '‚ùå UI not accessible on localhost:3000'
              exit 1
            fi

            if curl -f -s --max-time 5 http://127.0.0.1:1337/ > /dev/null; then
              echo '‚úÖ Strapi running on localhost:1337'
            else
              echo '‚ùå Strapi not accessible on localhost:1337'
              exit 1
            fi

            echo 'üìä Final system status:'
            df -h /opt
            docker system df
          "

          echo "‚úÖ Deployment verification completed at: $(date)"

      - name: Notify deployment success
        if: success()
        run: echo "üöÄ Multi-Site Deployment successful!"

      - name: Debug deployment failure
        if: failure()
        timeout-minutes: 5  # Limit debug collection to 5 minutes
        run: |
          echo "‚ùå Multi-Site Deployment failed!"
          echo "üìä Collecting debug information..."
          echo "‚è±Ô∏è  Debug collection timeout: 5 minutes"
          echo "üìä Debug collection started at: $(date)"

          # Test SSH connectivity first before collecting debug info
          echo "üîç Testing SSH connectivity for debug collection..."
          if ! timeout 10 ssh -o ConnectTimeout=5 -o BatchMode=yes ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "echo 'SSH OK'" 2>/dev/null; then
            echo "‚ùå SSH connection failed - cannot collect remote debug information"
            echo "üîç Connection troubleshooting:"
            echo "Host: ${{ secrets.DROPLET_HOST }}"
            echo "User: ${{ env.DEPLOY_USER }}"
            echo "Possible issues:"
            echo "1. Server is down or unreachable"
            echo "2. SSH service is not running"
            echo "3. Firewall blocking SSH (port 22)"
            echo "4. SSH key authentication failed"
            echo "5. Deploy user doesn't exist or lacks SSH access"

            # Try basic connectivity test
            echo "Testing basic network connectivity..."
            timeout 10 nc -zv ${{ secrets.DROPLET_HOST }} 22 2>/dev/null || echo "Port 22 not reachable"

            echo "üìä Debug collection completed at: $(date) (SSH failed)"
            exit 0  # Don't fail the entire workflow due to debug collection issues
          fi

          # Collect system information with timeouts
          timeout 300 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            echo '=== SYSTEM STATUS ==='
            timeout 10 date || echo 'date command timed out'
            timeout 10 uptime || echo 'uptime command timed out'
            timeout 15 df -h || echo 'df command timed out'
            timeout 10 free -h || echo 'free command timed out'

            echo '=== DOCKER STATUS ==='
            timeout 10 docker --version || echo 'docker version check timed out'
            timeout 10 docker-compose --version || echo 'docker-compose version check timed out'
            timeout 30 docker system df || echo 'docker system df timed out'
            timeout 20 docker images | head -10 || echo 'docker images command timed out'

            echo '=== CONTAINER STATUS ==='
            cd /opt/${{ env.PROJECT_NAME }} || exit 1
            timeout 30 docker-compose -f docker-compose.multi-site.yml ps || echo 'container status check timed out'

            echo '=== CONTAINER LOGS (last 50 lines each) ==='
            timeout 60 docker-compose -f docker-compose.multi-site.yml logs --tail=50 ui || echo 'UI logs collection timed out'
            timeout 60 docker-compose -f docker-compose.multi-site.yml logs --tail=50 strapi || echo 'Strapi logs collection timed out'

            echo '=== NGINX STATUS ==='
            timeout 15 systemctl status nginx || echo 'nginx status check timed out'
            timeout 10 nginx -t || echo 'nginx config test timed out'
            timeout 10 ls -la /etc/nginx/sites-enabled/ || echo 'nginx sites listing timed out'

            echo '=== NETWORK STATUS ==='
            timeout 15 netstat -tulpn | grep -E ':(80|443|3000|1337)' || echo 'network status check timed out'

            echo '=== RECENT SYSTEM LOGS ==='
            timeout 30 journalctl --since '10 minutes ago' --no-pager | tail -50 || echo 'system logs collection timed out'

            echo '=== DEBUG COLLECTION COMPLETED ==='
            date
          " || echo "‚ö†Ô∏è Debug information collection failed or timed out"

          echo "üìä Debug collection completed at: $(date)"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå Multi-Site Deployment failed!"
          echo "üìã Common issues to check:"
          echo "1. Run setup-existing-droplet.sh first for multi-site setup"
          echo "2. Ensure nginx is properly configured for multi-site"
          echo "3. Check that ports 3000 and 1337 are available"
          echo "4. Verify sufficient disk space and memory"
          echo "5. Check the debug information above for specific errors"
