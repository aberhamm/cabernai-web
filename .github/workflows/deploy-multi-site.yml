# GitHub Actions workflow for deploying to DigitalOcean droplet (MULTI-SITE VERSION)
# Save this file as .github/workflows/deploy-multi-site.yml
#
# IMPORTANT: This is for MULTI-SITE deployment only!
# You MUST run setup-existing-droplet.sh on your server first!

name: Deploy to DigitalOcean (Multi-Site)

on:
  push:
    branches:
      - main
      - production
  workflow_dispatch:

env:
  PROJECT_NAME: cabernai-web
  DEPLOY_USER: deploy

jobs:
  test:
    name: Test & Build
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Fix Sharp module for Linux CI
        run: |
          echo "üîß Fixing Sharp module for Linux CI environment..."
          # Force reinstall Sharp with correct platform binary
          rm -rf node_modules/@img/sharp* || true
          rm -rf node_modules/sharp || true
          yarn install --include=optional
          echo "‚úÖ Sharp module reinstalled for Linux platform"

      - name: Lint code
        env:
          # Skip Sharp module during linting to avoid platform compatibility issues
          NEXT_SHARP: 0
        run: NODE_ENV=development yarn turbo lint

      - name: Type check
        env:
          # Skip Sharp module during type generation to avoid platform compatibility issues
          NEXT_SHARP: 0
        run: |
          cd apps/ui && NODE_ENV=development yarn typecheck
          echo "‚ö†Ô∏è Skipping Strapi type generation in CI due to Sharp dependency conflicts"
          echo "‚úÖ Strapi types will be generated during deployment on the server where Sharp is properly installed"

      - name: Build applications
        env:
          # Production environment variables for build - derived from domain
          NEXT_PUBLIC_APP_PUBLIC_URL: https://${{ vars.DOMAIN_NAME }}
          NEXT_PUBLIC_STRAPI_URL: https://${{ vars.DOMAIN_NAME }}
          NODE_ENV: production
          # Skip Sharp module during build to avoid platform compatibility issues
          NEXT_SHARP: 0
        run: |
          echo "üîç Debug: DOMAIN_NAME = '${{ vars.DOMAIN_NAME }}'"
          echo "üîç Debug: NEXT_PUBLIC_APP_PUBLIC_URL = '$NEXT_PUBLIC_APP_PUBLIC_URL'"
          echo "üîç Debug: NEXT_PUBLIC_STRAPI_URL = '$NEXT_PUBLIC_STRAPI_URL'"
          echo "üîç Debug: NEXT_SHARP = '$NEXT_SHARP'"
          yarn build

  deploy:
    name: Deploy to Production (Multi-Site)
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://${{ vars.DOMAIN_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          echo "üîç Setting up SSH connection to ${{ secrets.DROPLET_HOST }}..."

          # Try ssh-keyscan first (preferred method)
          echo "Attempting ssh-keyscan..."
          if timeout 30 ssh-keyscan -H ${{ secrets.DROPLET_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "‚úÖ Successfully added ${{ secrets.DROPLET_HOST }} to known hosts via ssh-keyscan"
          else
            echo "‚ö†Ô∏è ssh-keyscan failed, using StrictHostKeyChecking=no as fallback"
            echo "This is safe for automated deployments to known servers"

            # Create SSH config to disable host key checking for this specific host
            mkdir -p ~/.ssh
            cat >> ~/.ssh/config << EOF
          Host ${{ secrets.DROPLET_HOST }}
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null
              LogLevel ERROR
          EOF

            echo "‚úÖ SSH configured to skip host key verification for deployment"
          fi

      - name: Verify multi-site setup exists
        run: |
          echo "üîç Testing SSH connection and verifying multi-site setup..."

          # Test SSH connection first
          if ! timeout 30 ssh -o ConnectTimeout=10 -o BatchMode=yes ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "echo 'SSH connection successful'"; then
            echo "‚ùå SSH connection failed!"
            echo "üîç Troubleshooting steps:"
            echo "1. Check if DROPLET_HOST secret is correct: ${{ secrets.DROPLET_HOST }}"
            echo "2. Verify SSH_PRIVATE_KEY secret is the correct private key"
            echo "3. Ensure the deploy user exists and has the correct public key"
            echo "4. Check if the server is running and accessible"
            exit 1
          fi

          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            # Check if multi-site setup was completed
            if [[ ! -f /opt/${{ env.PROJECT_NAME }}/docker-compose.multi-site.yml ]]; then
              echo '‚ùå Multi-site setup not found!'
              echo 'You must run setup-existing-droplet.sh on your server first.'
              echo 'See README-DEPLOYMENT.md multi-site section for instructions.'
              exit 1
            fi

            # Check if nginx is running (should exist for multi-site)
            if ! systemctl is-active --quiet nginx; then
              echo '‚ùå Nginx not running! Multi-site requires existing nginx.'
              exit 1
            fi

            echo '‚úÖ Multi-site environment verified'
          "

      - name: Create deployment directory
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            sudo mkdir -p /opt/${{ env.PROJECT_NAME }}
            sudo chown ${{ env.DEPLOY_USER }}:${{ env.DEPLOY_USER }} /opt/${{ env.PROJECT_NAME }}
          "

      - name: Copy project files
        run: |
          rsync -avz --delete \
            --exclude node_modules \
            --exclude .git \
            --exclude .env \
            --exclude dist \
            --exclude .next \
            --exclude .cache \
            --exclude .tmp \
            ./ ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }}:/opt/${{ env.PROJECT_NAME }}/

      - name: Create environment file
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            cd /opt/${{ env.PROJECT_NAME }}

            # Create single .env file - automatically loaded into all containers via env_file directive
            cat > .env << 'EOF'
          # URLs - consolidated from domain name (public, not sensitive)
          NEXT_PUBLIC_APP_PUBLIC_URL=https://${{ vars.DOMAIN_NAME }}
          NEXT_PUBLIC_STRAPI_URL=https://${{ vars.DOMAIN_NAME }}
          NEXTAUTH_URL=https://${{ vars.DOMAIN_NAME }}
          APP_URL=https://${{ vars.DOMAIN_NAME }}

          # Database - DATABASE_URL is primary, individual params for compatibility
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          DATABASE_SCHEMA=${{ secrets.DATABASE_SCHEMA }}
          DATABASE_CLIENT=postgres
          DATABASE_HOST=${{ secrets.DATABASE_HOST }}
          DATABASE_PORT=${{ secrets.DATABASE_PORT }}
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_SSL=${{ secrets.DATABASE_SSL }}

          # Strapi secrets
          APP_KEYS=${{ secrets.APP_KEYS }}
          ADMIN_JWT_SECRET=${{ secrets.ADMIN_JWT_SECRET }}
          API_TOKEN_SALT=${{ secrets.API_TOKEN_SALT }}
          TRANSFER_TOKEN_SALT=${{ secrets.TRANSFER_TOKEN_SALT }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          PUBLIC_URL=https://${{ vars.DOMAIN_NAME }}
          HOST=0.0.0.0
          PORT=1337

          # NextAuth
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
          # NextAuth URL already set above

          # File upload - Cloudinary (name duplicated for Next.js compatibility)
          CLOUDINARY_NAME=${{ secrets.CLOUDINARY_NAME }}
          CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}
          NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_NAME }}

          # Optional services
          MAILGUN_API_KEY=${{ secrets.MAILGUN_API_KEY }}
          MAILGUN_DOMAIN=${{ secrets.MAILGUN_DOMAIN }}
          MAILGUN_EMAIL=${{ secrets.MAILGUN_EMAIL }}

          # Monitoring - Sentry (DSN duplicated for Next.js compatibility)
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          NEXT_PUBLIC_SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          SENTRY_ORG=${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT=${{ secrets.SENTRY_PROJECT }}
          SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_SUPPRESS_GLOBAL_ERROR_HANDLER_FILE_WARNING=1

          # System
          CRON_ENABLED=true
          NODE_ENV=production
          NEXT_OUTPUT=standalone
          NEXT_IMAGES_UNOPTIMIZED=false

          # Additional Strapi Configuration
          CLIENT_URL=https://${{ vars.DOMAIN_NAME }}
          CLIENT_ACCOUNT_ACTIVATION_URL=https://${{ vars.DOMAIN_NAME }}/auth/activate
          EOF

            echo '‚úÖ Created single .env file - automatically loaded into ALL containers!'
          "

      - name: Deploy application (Multi-Site)
        timeout-minutes: 30 # Reduced timeout due to optimizations
        run: |
          echo "üöÄ Starting optimized multi-site deployment..."
          echo "‚è±Ô∏è  Deployment timeout: 30 minutes (reduced from 45 due to build optimizations)"
          echo "üìä Deployment started at: $(date)"

          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            cd /opt/${{ env.PROJECT_NAME }}

            # Show initial system status
            echo '=== SYSTEM STATUS ==='
            free -h && df -h && nproc

            # Build and deploy with Docker Compose
            echo 'üê≥ Starting Docker build and deployment...'
            echo 'This may take some time, especially on the first run...'

            # Ensure clean state
            echo 'üßπ Cleaning up any existing containers...'
            docker-compose -f docker-compose.multi-site.yml down --remove-orphans || true

            # Show Docker system info
            echo 'üìä Docker system status before build:'
            docker system df
            docker system info

            # Build with detailed output
            echo 'üèóÔ∏è Building images...'
            DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 docker-compose -f docker-compose.multi-site.yml build --parallel --build-arg BUILDKIT_INLINE_CACHE=1 --progress=plain

            # Start services with detailed logging
            echo 'üöÄ Starting services...'
            docker-compose -f docker-compose.multi-site.yml up -d --remove-orphans --force-recreate

            # Show immediate status
            echo 'üìä Initial container status:'
            docker ps -a

            # Wait for services and show logs in real-time with enhanced monitoring
            echo '‚è≥ Waiting for services to be healthy...'
            timeout 300s bash -c '
              attempt=1
              max_attempts=30

              while [ $attempt -le $max_attempts ]; do
                echo "üîç Health check attempt $attempt/$max_attempts..."

                # Check for exited containers first
                if docker-compose -f docker-compose.multi-site.yml ps | grep -q "Exit"; then
                  echo "‚ùå Container(s) exited unexpectedly!"
                  echo "üìä Container status:"
                  docker-compose -f docker-compose.multi-site.yml ps
                  echo "üìã Container logs (last 50 lines):"
                  docker-compose -f docker-compose.multi-site.yml logs --tail=50 --timestamps
                  echo "üìä System resources:"
                  free -h && df -h /opt
                  exit 1
                fi

                # Count running containers more reliably
                RUNNING_COUNT=$(docker-compose -f docker-compose.multi-site.yml ps -q | wc -l)
                HEALTHY_COUNT=0

                # Check each service individually
                if docker-compose -f docker-compose.multi-site.yml ps ui | grep -q "Up"; then
                  HEALTHY_COUNT=$((HEALTHY_COUNT + 1))
                  echo "‚úÖ UI service is running"
                else
                  echo "‚è≥ UI service not ready yet"
                fi

                if docker-compose -f docker-compose.multi-site.yml ps strapi | grep -q "Up"; then
                  HEALTHY_COUNT=$((HEALTHY_COUNT + 1))
                  echo "‚úÖ Strapi service is running"
                else
                  echo "‚è≥ Strapi service not ready yet"
                fi

                if [ "$HEALTHY_COUNT" -eq 2 ]; then
                  echo "‚úÖ All services are running! ($HEALTHY_COUNT/2)"

                  # Quick connectivity test
                  echo "üîç Testing basic connectivity..."
                  if timeout 10 curl -f -s http://127.0.0.1:3000/ > /dev/null 2>&1; then
                    echo "‚úÖ UI responding on port 3000"
                  else
                    echo "‚è≥ UI not responding yet on port 3000"
                  fi

                  if timeout 10 curl -f -s http://127.0.0.1:1337/ > /dev/null 2>&1; then
                    echo "‚úÖ Strapi responding on port 1337"
                  else
                    echo "‚è≥ Strapi not responding yet on port 1337"
                  fi

                  break
                fi

                echo "‚è≥ Waiting for services... ($HEALTHY_COUNT/2 healthy)"

                # Show container status every few attempts
                if [ $((attempt % 3)) -eq 0 ]; then
                  echo "üìä Current container status:"
                  docker-compose -f docker-compose.multi-site.yml ps
                fi

                # Show recent logs every 5 attempts
                if [ $((attempt % 5)) -eq 0 ]; then
                  echo "üìã Recent logs (last 10 lines):"
                  docker-compose -f docker-compose.multi-site.yml logs --tail=10 --timestamps
                fi

                attempt=$((attempt + 1))
                sleep 10
              done

              if [ $attempt -gt $max_attempts ]; then
                echo "‚ùå Services failed to become healthy within timeout"
                echo "üìä Final container status:"
                docker-compose -f docker-compose.multi-site.yml ps
                echo "üìã Final logs:"
                docker-compose -f docker-compose.multi-site.yml logs --tail=50 --timestamps
                exit 1
              fi
            '

            # Show final status and logs
            echo 'üìä Final container status:'
            docker-compose -f docker-compose.multi-site.yml ps
            echo 'üìã Container logs:'
            docker-compose -f docker-compose.multi-site.yml logs --no-color --tail=200

            # Verify network connectivity
            echo 'üîç Testing container networking:'
            docker network ls
            docker network inspect cabernai_network || true

            # Show resource usage
            echo 'üìä Resource usage:'
            docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}"

            # Prune old docker images/containers
            echo 'üßπ Pruning old Docker assets...'
            docker image prune -f
            docker container prune -f

            # Configure nginx for multi-site
            echo 'üöÄ Configuring and reloading Nginx for multi-site...'
            sudo cp -f nginx/sites-available/cabernai-web /etc/nginx/sites-available/cabernai-web
            sudo ln -sf /etc/nginx/sites-available/cabernai-web /etc/nginx/sites-enabled/

            # Test and reload nginx with sudo
            echo 'üîç Testing Nginx configuration...'
            sudo nginx -t
            echo '‚úÖ Nginx configuration test successful!'
            echo 'üîÑ Reloading Nginx...'
            sudo systemctl reload nginx

            echo '‚úÖ Nginx reloaded successfully!'
            echo 'üéâ Multi-site deployment completed successfully!'
            echo 'üìä Deployment finished at: $(date)'
          "
        continue-on-error: false # Fail the workflow on deployment error

      - name: Collect Debug Info on Failure
        if: failure()
        run: |
          echo "##[group]Collecting Debug Information"
          echo "‚ùå Deployment failed! Collecting debug information..."
          echo "üìä Debug collection started at: $(date)"

          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            echo '##[group]SYSTEM STATUS'
            echo '=== SYSTEM STATUS ==='
            free -h && df -h && nproc
            echo '##[endgroup]'

            echo '##[group]DOCKER STATUS'
            echo '=== DOCKER STATUS ==='
            sudo docker ps -a
            sudo docker images
            echo '##[endgroup]'

            echo '##[group]NGINX CONFIG'
            echo '=== NGINX CONFIGURATION ==='
            sudo nginx -T
            echo '##[endgroup]'

            echo '##[group]NGINX LOGS'
            echo '=== NGINX LOGS (last 50 lines) ==='
            sudo journalctl -u nginx.service -n 50 --no-pager
            echo '##[endgroup]'

            echo '##[group]SYSTEM LOGS'
            echo '=== RECENT SYSTEM LOGS (last 50 lines) ==='
            journalctl -n 50 --no-pager
            echo '##[endgroup]'
          "
          echo "üìä Debug collection completed at: $(date)"
          exit 1 # Ensure the job fails after collecting logs

      - name: Verify deployment
        timeout-minutes: 10  # Set timeout for verification
        run: |
          echo "üîç Starting deployment verification..."
          echo "‚è±Ô∏è  Verification timeout: 10 minutes"
          echo "üìä Verification started at: $(date)"

          # Progressive verification with better logging and safety checks
          echo "‚è≥ Waiting for services to fully initialize..."
          max_attempts=12
          attempt_timeout=15  # timeout per attempt
          total_timeout=300   # 5 minutes total
          start_time=$(date +%s)

          for i in $(seq 1 $max_attempts); do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))

            # Safety check: abort if total time exceeded
            if [[ $elapsed -gt $total_timeout ]]; then
              echo "üö® SAFETY: Total verification time exceeded ${total_timeout}s. Aborting."
              exit 1
            fi

            # Safety check: validate iteration number
            if [[ ! $i =~ ^[0-9]+$ ]] || [[ $i -lt 1 ]] || [[ $i -gt $max_attempts ]]; then
              echo "üö® SAFETY: Invalid iteration number: $i. Aborting."
              exit 1
            fi

            echo "üîç Verification attempt $i/$max_attempts (${elapsed}s elapsed, max ${total_timeout}s)..."

            # Use timeout for sleep to prevent hanging
            timeout $attempt_timeout sleep 10 || {
              echo "üö® SAFETY: Sleep command timed out. System may be unresponsive."
              exit 1
            }

            # Enhanced container status check with better error handling
            echo "üìä Checking container status..."
            container_status_output=""
            if container_status_output=$(timeout 30 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
              cd /opt/${{ env.PROJECT_NAME }}
              echo 'üìä Container status:'
              docker-compose -f docker-compose.multi-site.yml ps
              echo 'üìä All containers (including stopped):'
              docker ps -a --filter 'label=com.docker.compose.project=cabernai-web' --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
              echo 'üìä Docker system status:'
              docker system df
              echo 'üìä Network status:'
              docker network ls | grep cabernai || echo 'No cabernai network found'
            " 2>&1); then
              echo "$container_status_output"

              # Check if any containers are running
              if echo "$container_status_output" | grep -q "Up"; then
                echo "‚úÖ Found running containers"
              else
                echo "‚ö†Ô∏è No running containers found"
                # Show container logs for debugging
                echo "üìã Checking why containers aren't running..."
                timeout 60 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
                  cd /opt/${{ env.PROJECT_NAME }}
                  echo 'üìã Recent container logs:'
                  docker-compose -f docker-compose.multi-site.yml logs --tail=20 --timestamps || echo 'No logs available'
                  echo 'üìã Container inspect for stopped containers:'
                  docker ps -a --filter 'label=com.docker.compose.project=cabernai-web' --format '{{.Names}}' | head -5 | while read container; do
                    if [ -n \"\$container\" ]; then
                      echo \"--- \$container ---\"
                      docker inspect \"\$container\" --format '{{.State.Status}}: {{.State.Error}}' 2>/dev/null || echo 'Inspect failed'
                    fi
                  done
                " || echo "Container debugging failed"
              fi
            else
              echo "‚ö†Ô∏è Container status check failed or timed out"
              echo "Error output: $container_status_output"
            fi

            # Test local endpoints with better error handling
            echo "üîç Testing local endpoints..."
            local_endpoints_ok=false

            # Test UI endpoint
            if timeout 15 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
              timeout 8 curl -f -s --max-time 5 http://127.0.0.1:3000/ > /dev/null 2>&1
            "; then
              echo "‚úÖ UI endpoint (3000) responding"
              ui_ok=true
            else
              echo "‚ùå UI endpoint (3000) not responding"
              ui_ok=false
            fi

            # Test Strapi endpoint
            if timeout 15 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
              timeout 8 curl -f -s --max-time 5 http://127.0.0.1:1337/ > /dev/null 2>&1
            "; then
              echo "‚úÖ Strapi endpoint (1337) responding"
              strapi_ok=true
            else
              echo "‚ùå Strapi endpoint (1337) not responding"
              strapi_ok=false
            fi

            # Check if both endpoints are working
            if [[ "$ui_ok" == "true" && "$strapi_ok" == "true" ]]; then
              echo "‚úÖ Both local endpoints responding, testing public endpoints..."
              local_endpoints_ok=true
              break
            elif [[ $i -eq $max_attempts ]]; then
              echo "‚ùå Local endpoints not responding after $max_attempts attempts (${elapsed}s total)"
              echo "üîç Final debugging attempt..."

              # Enhanced debugging for failed deployment
              timeout 120 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
                cd /opt/${{ env.PROJECT_NAME }}

                echo '=== FINAL DEBUG INFO ==='
                echo 'üìä System resources:'
                free -h && df -h /opt

                echo 'üìä Docker status:'
                docker --version && docker-compose --version
                docker system df

                echo 'üìä All containers:'
                docker ps -a

                echo 'üìä Compose project containers:'
                docker-compose -f docker-compose.multi-site.yml ps -a

                echo 'üìä Network status:'
                netstat -tulpn | grep -E ':(3000|1337)' || echo 'Ports 3000/1337 not bound'

                echo 'üìã Recent logs (last 30 lines per service):'
                docker-compose -f docker-compose.multi-site.yml logs --tail=30 --timestamps ui 2>/dev/null || echo 'No UI logs'
                echo '---'
                docker-compose -f docker-compose.multi-site.yml logs --tail=30 --timestamps strapi 2>/dev/null || echo 'No Strapi logs'

                echo 'üìä Docker events (last 50):'
                docker events --since '10m' --until '0s' 2>/dev/null | tail -50 || echo 'No recent events'

                echo '=== END DEBUG INFO ==='
              " || echo "Final debug collection failed"

              exit 1
            else
              echo "‚è≥ Services still initializing... (attempt $i/$max_attempts)"
              ui_status="‚ùå"; [[ "$ui_ok" == "true" ]] && ui_status="‚úÖ"
              strapi_status="‚ùå"; [[ "$strapi_ok" == "true" ]] && strapi_status="‚úÖ"
              echo "   UI: $ui_status | Strapi: $strapi_status"
            fi
          done

          # Only proceed to public endpoint testing if local endpoints are working
          if [[ "$local_endpoints_ok" != "true" ]]; then
            echo "‚ùå Skipping public endpoint tests - local endpoints not working"
            exit 1
          fi

          # Test public endpoints
          echo "üåê Testing public endpoints..."

          # Test UI through domain with safety checks
          ui_max_attempts=5
          ui_retry_delay=15
          ui_timeout=20

          for attempt in $(seq 1 $ui_max_attempts); do
            # Safety check: validate attempt number
            if [[ ! $attempt =~ ^[1-5]$ ]]; then
              echo "üö® SAFETY: Invalid UI attempt number: $attempt. Aborting."
              exit 1
            fi

            if timeout $ui_timeout curl -f -s --max-time 10 https://${{ vars.DOMAIN_NAME }}/ > /dev/null; then
              echo "‚úÖ UI is responding via https://${{ vars.DOMAIN_NAME }}/ (attempt $attempt)"
              break
            elif [[ $attempt -eq $ui_max_attempts ]]; then
              echo "‚ùå UI is not responding via public domain after $ui_max_attempts attempts"
              exit 1
            else
              echo "‚è≥ UI not ready via public domain, attempt $attempt/$ui_max_attempts..."
              timeout $((ui_retry_delay + 5)) sleep $ui_retry_delay || {
                echo "üö® SAFETY: UI retry sleep timed out. System may be unresponsive."
                exit 1
              }
            fi
          done

          # Test API through domain with safety checks
          api_max_attempts=5
          api_retry_delay=15
          api_timeout=20

          for attempt in $(seq 1 $api_max_attempts); do
            # Safety check: validate attempt number
            if [[ ! $attempt =~ ^[1-5]$ ]]; then
              echo "üö® SAFETY: Invalid API attempt number: $attempt. Aborting."
              exit 1
            fi

            if timeout $api_timeout curl -f -s --max-time 10 https://${{ vars.DOMAIN_NAME }}/api/ > /dev/null; then
              echo "‚úÖ API is responding via https://${{ vars.DOMAIN_NAME }}/api/ (attempt $attempt)"
              break
            elif [[ $attempt -eq $api_max_attempts ]]; then
              echo "‚ùå API is not responding via public domain after $api_max_attempts attempts"
              exit 1
            else
              echo "‚è≥ API not ready via public domain, attempt $attempt/$api_max_attempts..."
              timeout $((api_retry_delay + 5)) sleep $api_retry_delay || {
                echo "üö® SAFETY: API retry sleep timed out. System may be unresponsive."
                exit 1
              }
            fi
          done

          # Final verification of local ports
          echo "üîç Final verification of local ports..."
          ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            if curl -f -s --max-time 5 http://127.0.0.1:3000/ > /dev/null; then
              echo '‚úÖ UI running on localhost:3000'
            else
              echo '‚ùå UI not accessible on localhost:3000'
              exit 1
            fi

            if curl -f -s --max-time 5 http://127.0.0.1:1337/ > /dev/null; then
              echo '‚úÖ Strapi running on localhost:1337'
            else
              echo '‚ùå Strapi not accessible on localhost:1337'
              exit 1
            fi

            echo 'üìä Final system status:'
            df -h /opt
            docker system df
          "

          echo "‚úÖ Deployment verification completed at: $(date)"

      - name: Notify deployment success
        if: success()
        run: echo "üöÄ Multi-Site Deployment successful!"

      - name: Debug deployment failure
        if: failure()
        timeout-minutes: 5  # Limit debug collection to 5 minutes
        run: |
          echo "‚ùå Multi-Site Deployment failed!"
          echo "üìä Collecting debug information..."
          echo "‚è±Ô∏è  Debug collection timeout: 5 minutes"
          echo "üìä Debug collection started at: $(date)"

          # Test SSH connectivity first before collecting debug info
          echo "üîç Testing SSH connectivity for debug collection..."
          if ! timeout 10 ssh -o ConnectTimeout=5 -o BatchMode=yes ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "echo 'SSH OK'" 2>/dev/null; then
            echo "‚ùå SSH connection failed - cannot collect remote debug information"
            echo "üîç Connection troubleshooting:"
            echo "Host: ${{ secrets.DROPLET_HOST }}"
            echo "User: ${{ env.DEPLOY_USER }}"
            echo "Possible issues:"
            echo "1. Server is down or unreachable"
            echo "2. SSH service is not running"
            echo "3. Firewall blocking SSH (port 22)"
            echo "4. SSH key authentication failed"
            echo "5. Deploy user doesn't exist or lacks SSH access"

            # Try basic connectivity test
            echo "Testing basic network connectivity..."
            timeout 10 nc -zv ${{ secrets.DROPLET_HOST }} 22 2>/dev/null || echo "Port 22 not reachable"

            echo "üìä Debug collection completed at: $(date) (SSH failed)"
            exit 0  # Don't fail the entire workflow due to debug collection issues
          fi

          # Collect system information with timeouts
          timeout 300 ssh ${{ env.DEPLOY_USER }}@${{ secrets.DROPLET_HOST }} "
            echo '=== SYSTEM STATUS ==='
            timeout 10 date || echo 'date command timed out'
            timeout 10 uptime || echo 'uptime command timed out'
            timeout 15 df -h || echo 'df command timed out'
            timeout 10 free -h || echo 'free command timed out'

            echo '=== DOCKER STATUS ==='
            timeout 10 docker --version || echo 'docker version check timed out'
            timeout 10 docker-compose --version || echo 'docker-compose version check timed out'
            timeout 30 docker system df || echo 'docker system df timed out'
            timeout 20 docker images | head -10 || echo 'docker images command timed out'

            echo '=== CONTAINER STATUS ==='
            cd /opt/${{ env.PROJECT_NAME }} || exit 1
            timeout 30 docker-compose -f docker-compose.multi-site.yml ps || echo 'container status check timed out'

            echo '=== CONTAINER LOGS (last 50 lines each) ==='
            timeout 60 docker-compose -f docker-compose.multi-site.yml logs --tail=50 ui || echo 'UI logs collection timed out'
            timeout 60 docker-compose -f docker-compose.multi-site.yml logs --tail=50 strapi || echo 'Strapi logs collection timed out'

            echo '=== NGINX STATUS ==='
            timeout 15 systemctl status nginx || echo 'nginx status check timed out'
            timeout 10 nginx -t || echo 'nginx config test timed out'
            timeout 10 ls -la /etc/nginx/sites-enabled/ || echo 'nginx sites listing timed out'

            echo '=== NETWORK STATUS ==='
            timeout 15 netstat -tulpn | grep -E ':(80|443|3000|1337)' || echo 'network status check timed out'

            echo '=== RECENT SYSTEM LOGS ==='
            timeout 30 journalctl --since '10 minutes ago' --no-pager | tail -50 || echo 'system logs collection timed out'

            echo '=== DEBUG COLLECTION COMPLETED ==='
            date
          " || echo "‚ö†Ô∏è Debug information collection failed or timed out"

          echo "üìä Debug collection completed at: $(date)"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå Multi-Site Deployment failed!"
          echo "üìã Common issues to check:"
          echo "1. Run setup-existing-droplet.sh first for multi-site setup"
          echo "2. Ensure nginx is properly configured for multi-site"
          echo "3. Check that ports 3000 and 1337 are available"
          echo "4. Verify sufficient disk space and memory"
          echo "5. Check the debug information above for specific errors"
